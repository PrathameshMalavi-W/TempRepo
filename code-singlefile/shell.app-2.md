#libs-Folder => onecx-shell-ui

Folder Shared/api
********************************************************************************************************************************

FIle => onecx-shell-ui > src > shared > generated > api.ts
```ts
export * from './icon.service';
import { IconBffService } from './icon.service';
export * from './parameter.service';
import { ParameterBffService } from './parameter.service';
export * from './permission.service';
import { PermissionBffService } from './permission.service';
export * from './userProfile.service';
import { UserProfileBffService } from './userProfile.service';
export * from './workspaceConfig.service';
import { WorkspaceConfigBffService } from './workspaceConfig.service';
export const APIS = [IconBffService, ParameterBffService, PermissionBffService, UserProfileBffService, WorkspaceConfigBffService];

```


FIle => onecx-shell-ui > src > shared > generated > permission.service.ts
```ts
/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { GetPermissionsRequest } from '../model/getPermissionsRequest';
// @ts-ignore
import { GetPermissionsResponse } from '../model/getPermissionsResponse';
// @ts-ignore
import { ProblemDetailResponse } from '../model/problemDetailResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'any'
})
export class PermissionBffService {

    protected basePath = 'http://onecx-shell-bff:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (Array.isArray(basePath) && basePath.length > 0) {
                basePath = basePath[0];
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get all permissions for a specific application by its id and product name
     * @param getPermissionsRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPermissions(getPermissionsRequest: GetPermissionsRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetPermissionsResponse>;
    public getPermissions(getPermissionsRequest: GetPermissionsRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetPermissionsResponse>>;
    public getPermissions(getPermissionsRequest: GetPermissionsRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetPermissionsResponse>>;
    public getPermissions(getPermissionsRequest: GetPermissionsRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (getPermissionsRequest === null || getPermissionsRequest === undefined) {
            throw new Error('Required parameter getPermissionsRequest was null or undefined when calling getPermissions.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/permissions`;
        return this.httpClient.request<GetPermissionsResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: getPermissionsRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

```


FIle => onecx-shell-ui > src > shared > generated > icon.service.ts
```ts
/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { IconCriteria } from '../model/iconCriteria';
// @ts-ignore
import { IconListResponse } from '../model/iconListResponse';
// @ts-ignore
import { ProblemDetailResponse } from '../model/problemDetailResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'any'
})
export class IconBffService {

    protected basePath = 'http://onecx-shell-bff:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (Array.isArray(basePath) && basePath.length > 0) {
                basePath = basePath[0];
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Retrieve icons by list of names and refId
     * @param refId 
     * @param iconCriteria 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findIconsByNamesAndRefId(refId: string, iconCriteria: IconCriteria, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<IconListResponse>;
    public findIconsByNamesAndRefId(refId: string, iconCriteria: IconCriteria, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<IconListResponse>>;
    public findIconsByNamesAndRefId(refId: string, iconCriteria: IconCriteria, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<IconListResponse>>;
    public findIconsByNamesAndRefId(refId: string, iconCriteria: IconCriteria, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (refId === null || refId === undefined) {
            throw new Error('Required parameter refId was null or undefined when calling findIconsByNamesAndRefId.');
        }
        if (iconCriteria === null || iconCriteria === undefined) {
            throw new Error('Required parameter iconCriteria was null or undefined when calling findIconsByNamesAndRefId.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/icons/${this.configuration.encodeParam({name: "refId", value: refId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<IconListResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: iconCriteria,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
}

```


FIle => onecx-shell-ui > src > shared > generated > parameter.service.ts
```ts
/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { GetParametersRequest } from '../model/getParametersRequest';
// @ts-ignore
import { GetParametersResponse } from '../model/getParametersResponse';
// @ts-ignore
import { ProblemDetailResponse } from '../model/problemDetailResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'any'
})
export class ParameterBffService {

    protected basePath = 'http://onecx-shell-bff:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (Array.isArray(basePath) && basePath.length > 0) {
                basePath = basePath[0];
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get all available parameters of the requested products
     * @param getParametersRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getParameters(getParametersRequest: GetParametersRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetParametersResponse>;
    public getParameters(getParametersRequest: GetParametersRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetParametersResponse>>;
    public getParameters(getParametersRequest: GetParametersRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetParametersResponse>>;
    public getParameters(getParametersRequest: GetParametersRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (getParametersRequest === null || getParametersRequest === undefined) {
            throw new Error('Required parameter getParametersRequest was null or undefined when calling getParameters.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/parameters`;
        return this.httpClient.request<GetParametersResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: getParametersRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

```


FIle => onecx-shell-ui > src > shared > generated > userProfile.service.ts
```ts
/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { GetUserProfileResponse } from '../model/getUserProfileResponse';
// @ts-ignore
import { ProblemDetailResponse } from '../model/problemDetailResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'any'
})
export class UserProfileBffService {

    protected basePath = 'http://onecx-shell-bff:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (Array.isArray(basePath) && basePath.length > 0) {
                basePath = basePath[0];
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get the user profile of the requesting user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUserProfile(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<GetUserProfileResponse>;
    public getUserProfile(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<GetUserProfileResponse>>;
    public getUserProfile(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<GetUserProfileResponse>>;
    public getUserProfile(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/userProfile`;
        return this.httpClient.request<GetUserProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

```


FIle => onecx-shell-ui > src > shared > generated > workspaceConfig.service.ts
```ts
/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { AvailableImageTypes } from '../model/availableImageTypes';
// @ts-ignore
import { LoadWorkspaceConfigRequest } from '../model/loadWorkspaceConfigRequest';
// @ts-ignore
import { LoadWorkspaceConfigResponse } from '../model/loadWorkspaceConfigResponse';
// @ts-ignore
import { ProblemDetailResponse } from '../model/problemDetailResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'any'
})
export class WorkspaceConfigBffService {

    protected basePath = 'http://onecx-shell-bff:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (Array.isArray(basePath) && basePath.length > 0) {
                basePath = basePath[0];
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get available image types
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAvailableImageTypes(name: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<AvailableImageTypes>;
    public getAvailableImageTypes(name: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<AvailableImageTypes>>;
    public getAvailableImageTypes(name: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<AvailableImageTypes>>;
    public getAvailableImageTypes(name: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAvailableImageTypes.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/workspaceConfig/themes/${this.configuration.encodeParam({name: "name", value: name, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/images/availableTypes`;
        return this.httpClient.request<AvailableImageTypes>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get favicon of a theme by its name
     * @param name 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getThemeFaviconByName(name: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-icon', context?: HttpContext}): Observable<Blob>;
    public getThemeFaviconByName(name: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-icon', context?: HttpContext}): Observable<HttpResponse<Blob>>;
    public getThemeFaviconByName(name: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/x-icon', context?: HttpContext}): Observable<HttpEvent<Blob>>;
    public getThemeFaviconByName(name: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/x-icon', context?: HttpContext}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getThemeFaviconByName.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/x-icon'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let localVarPath = `/workspaceConfig/themes/${this.configuration.encodeParam({name: "name", value: name, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/favicon`;
        return this.httpClient.request('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get an image of a theme by its reference name (theme name) and reference type
     * @param name 
     * @param refType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getThemeImageByNameAndRefType(name: string, refType: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/*', context?: HttpContext}): Observable<Blob>;
    public getThemeImageByNameAndRefType(name: string, refType: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/*', context?: HttpContext}): Observable<HttpResponse<Blob>>;
    public getThemeImageByNameAndRefType(name: string, refType: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/*', context?: HttpContext}): Observable<HttpEvent<Blob>>;
    public getThemeImageByNameAndRefType(name: string, refType: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/*', context?: HttpContext}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getThemeImageByNameAndRefType.');
        }
        if (refType === null || refType === undefined) {
            throw new Error('Required parameter refType was null or undefined when calling getThemeImageByNameAndRefType.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/*'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let localVarPath = `/workspaceConfig/themes/${this.configuration.encodeParam({name: "name", value: name, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/images/${this.configuration.encodeParam({name: "refType", value: refType, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the logo of a theme by its name
     * @param name 
     * @param small 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getThemeLogoByName(name: string, small?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/*', context?: HttpContext}): Observable<Blob>;
    public getThemeLogoByName(name: string, small?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/*', context?: HttpContext}): Observable<HttpResponse<Blob>>;
    public getThemeLogoByName(name: string, small?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'image/*', context?: HttpContext}): Observable<HttpEvent<Blob>>;
    public getThemeLogoByName(name: string, small?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'image/*', context?: HttpContext}): Observable<any> {
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getThemeLogoByName.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (small !== undefined && small !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>small, 'small');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'image/*'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let localVarPath = `/workspaceConfig/themes/${this.configuration.encodeParam({name: "name", value: name, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/logo`;
        return this.httpClient.request('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Load all data needed by startup of OneCX UI (components, routes, slots, theme, workspace)
     * @param loadWorkspaceConfigRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loadWorkspaceConfig(loadWorkspaceConfigRequest: LoadWorkspaceConfigRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<LoadWorkspaceConfigResponse>;
    public loadWorkspaceConfig(loadWorkspaceConfigRequest: LoadWorkspaceConfigRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<LoadWorkspaceConfigResponse>>;
    public loadWorkspaceConfig(loadWorkspaceConfigRequest: LoadWorkspaceConfigRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<LoadWorkspaceConfigResponse>>;
    public loadWorkspaceConfig(loadWorkspaceConfigRequest: LoadWorkspaceConfigRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (loadWorkspaceConfigRequest === null || loadWorkspaceConfigRequest === undefined) {
            throw new Error('Required parameter loadWorkspaceConfigRequest was null or undefined when calling loadWorkspaceConfig.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/workspaceConfig`;
        return this.httpClient.request<LoadWorkspaceConfigResponse>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: loadWorkspaceConfigRequest,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }
}

```




Folder Shared/model
********************************************************************************************************************************
accounSetngs.ts
availablelmageTypes.ts
colorScheme.ts
getParametersRequestts
getParametersResponsets
getPermissionsRequest.ts
getPermissionsResponse.ts
getUserProfileResponse.ts
icon.ts
iconCriteria.ts
iconListResponse.ts
layoutAndThemeSettings.ts
loadWorkspaceConfigRequest.ts
loadWorkspaceConfigResponse.ts
localeAndTmeSettings.ts
menu Mode.ts
models.ts
overrideType.ts
parameter.ts
parameterValue.ts
pathMatch.ts
phoneType.ts
problemDetaillnvalidParam.ts
problemDetailParam.ts
problem Detai IResponse.ts
remoteComponent.ts
route. ts
slot.ts
technologies.ts
theme.ts
themeOverride.ts
ulEndpoint.ts
userPerson.ts
userPersonAddress.ts
userPersonPhone.ts
userProfile.ts
workspace.ts
```ts

/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { LayoutAndThemeSettings } from './layoutAndThemeSettings';
import { LocaleAndTimeSettings } from './localeAndTimeSettings';


export interface AccountSettings { 
    layoutAndThemeSettings?: LayoutAndThemeSettings;
    localeAndTimeSettings?: LocaleAndTimeSettings;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface AvailableImageTypes { 
    types?: Array<string>;
}


/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export enum ColorScheme {
    AUTO = 'AUTO',
    LIGHT = 'LIGHT',
    DARK = 'DARK'
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface GetParametersRequest { 
    products: { [key: string]: Array<string>; };
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Parameter } from './parameter';


export interface GetParametersResponse { 
    products: { [key: string]: { [key: string]: Array<Parameter>; }; };
}





/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface GetPermissionsRequest { 
    appId: string;
    productName: string;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface GetPermissionsResponse { 
    permissions: Array<string>;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { UserProfile } from './userProfile';


export interface GetUserProfileResponse { 
    userProfile: UserProfile;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface Icon { 
    name: string;
    type: string;
    body: string;
    parent?: string;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface IconCriteria { 
    names: Array<string>;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Icon } from './icon';


export interface IconListResponse { 
    icons?: Array<Icon>;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { ColorScheme } from './colorScheme';
import { MenuMode } from './menuMode';


export interface LayoutAndThemeSettings { 
    colorScheme?: ColorScheme;
    menuMode?: MenuMode;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface LoadWorkspaceConfigRequest { 
    path: string;
}


/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { RemoteComponent } from './remoteComponent';
import { Slot } from './slot';
import { Theme } from './theme';
import { Route } from './route';
import { Workspace } from './workspace';


export interface LoadWorkspaceConfigResponse { 
    routes: Array<Route>;
    theme: Theme;
    workspace: Workspace;
    components: Array<RemoteComponent>;
    slots: Array<Slot>;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface LocaleAndTimeSettings { 
    locale?: string;
    timezone?: string;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export enum MenuMode {
    HORIZONTAL = 'HORIZONTAL',
    STATIC = 'STATIC',
    OVERLAY = 'OVERLAY',
    SLIM = 'SLIM',
    SLIMPLUS = 'SLIMPLUS'
}



// FIle = > model.ts
export * from './accountSettings';
export * from './availableImageTypes';
export * from './colorScheme';
export * from './getParametersRequest';
export * from './getParametersResponse';
export * from './getPermissionsRequest';
export * from './getPermissionsResponse';
export * from './getUserProfileResponse';
export * from './icon';
export * from './iconCriteria';
export * from './iconListResponse';
export * from './layoutAndThemeSettings';
export * from './loadWorkspaceConfigRequest';
export * from './loadWorkspaceConfigResponse';
export * from './localeAndTimeSettings';
export * from './menuMode';
export * from './overrideType';
export * from './parameter';
export * from './parameterValue';
export * from './pathMatch';
export * from './phoneType';
export * from './problemDetailInvalidParam';
export * from './problemDetailParam';
export * from './problemDetailResponse';
export * from './remoteComponent';
export * from './route';
export * from './slot';
export * from './technologies';
export * from './theme';
export * from './themeOverride';
export * from './uIEndpoint';
export * from './userPerson';
export * from './userPersonAddress';
export * from './userPersonPhone';
export * from './userProfile';
export * from './workspace';



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export enum OverrideType {
    PRIMENG = 'PRIMENG',
    CSS = 'CSS'
}


/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { ParameterValue } from './parameterValue';


export interface Parameter { 
    displayName?: string;
    description?: string;
    applicationId: string;
    productName: string;
    name: string;
    value: ParameterValue;
    importValue?: ParameterValue;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


/**
 * @type ParameterValue
 * @export
 */
export type ParameterValue = boolean | number | object | string;



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export enum PathMatch {
    full = 'full',
    prefix = 'prefix'
}





/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export enum PhoneType {
    MOBILE = 'MOBILE',
    LANDLINE = 'LANDLINE'
}





/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface ProblemDetailInvalidParam { 
    name?: string;
    message?: string;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface ProblemDetailParam { 
    key?: string;
    value?: string;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { ProblemDetailInvalidParam } from './problemDetailInvalidParam';
import { ProblemDetailParam } from './problemDetailParam';


export interface ProblemDetailResponse { 
    errorCode?: string;
    detail?: string;
    params?: Array<ProblemDetailParam>;
    invalidParams?: Array<ProblemDetailInvalidParam>;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Technologies } from './technologies';


export interface RemoteComponent { 
    name: string;
    baseUrl: string;
    remoteEntryUrl: string;
    appId: string;
    productName: string;
    productVersion?: string;
    exposedModule: string;
    remoteName?: string;
    elementName?: string;
    technology?: Technologies;
}







/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Technologies } from './technologies';


export interface RemoteComponent { 
    name: string;
    baseUrl: string;
    remoteEntryUrl: string;
    appId: string;
    productName: string;
    productVersion?: string;
    exposedModule: string;
    remoteName?: string;
    elementName?: string;
    technology?: Technologies;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { PathMatch } from './pathMatch';
import { UIEndpoint } from './uIEndpoint';
import { Technologies } from './technologies';


export interface Route { 
    url: string;
    baseUrl: string;
    remoteEntryUrl: string;
    appId: string;
    productName: string;
    productVersion: string;
    technology?: Technologies;
    exposedModule: string;
    pathMatch: PathMatch;
    remoteName?: string;
    elementName?: string;
    displayName: string;
    endpoints?: Array<UIEndpoint>;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface Slot { 
    name: string;
    components: Array<string>;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export enum Technologies {
    Angular = 'Angular',
    WebComponent = 'WebComponent',
    WebComponentScript = 'WebComponentScript',
    WebComponentModule = 'WebComponentModule'
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { ThemeOverride } from './themeOverride';


export interface Theme { 
    displayName?: string;
    name: string;
    cssFile?: string;
    description?: string;
    assetsUrl?: string;
    logoUrl?: string;
    smallLogoUrl?: string;
    faviconUrl?: string;
    previewImageUrl?: string;
    assetsUpdateDate?: string;
    properties: string;
    overrides?: Array<ThemeOverride>;
}


/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { OverrideType } from './overrideType';


export interface ThemeOverride { 
    type?: OverrideType;
    value?: string;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface UIEndpoint { 
    path?: string;
    name?: string;
}


/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { UserPersonPhone } from './userPersonPhone';
import { UserPersonAddress } from './userPersonAddress';


export interface UserPerson { 
    firstName?: string;
    lastName?: string;
    displayName?: string;
    email?: string;
    address?: UserPersonAddress;
    phone?: UserPersonPhone;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { UserPersonPhone } from './userPersonPhone';
import { UserPersonAddress } from './userPersonAddress';


export interface UserPerson { 
    firstName?: string;
    lastName?: string;
    displayName?: string;
    email?: string;
    address?: UserPersonAddress;
    phone?: UserPersonPhone;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface UserPersonAddress { 
    street?: string;
    streetNo?: string;
    city?: string;
    postalCode?: string;
    country?: string;
}



/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { PhoneType } from './phoneType';


export interface UserPersonPhone { 
    type?: PhoneType;
    number?: string;
}





/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { AccountSettings } from './accountSettings';
import { UserPerson } from './userPerson';


export interface UserProfile { 
    userId: string;
    organization?: string;
    issuer?: string;
    tenantId?: string;
    person: UserPerson;
    accountSettings?: AccountSettings;
    settings?: object;
}




/**
 * onecx-shell-bff
 * This API provides endpoints to load essential data like workspace configurations for the shell
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface Workspace { 
    displayName?: string;
    name: string;
    baseUrl: string;
    homePage?: string;
    logoUrl?: string;
    smallLogoUrl?: string;
}




```







Folder assets/api
********************************************************************************************************************************

FIle => onecx-shell-ui > src > assets > api > openapi-bff.yaml

```yaml
---
openapi: 3.0.3
info:
  title: onecx-shell-bff
  description: This API provides endpoints to load essential data like workspace configurations for the shell
  version: 1.0.0
servers:
  - url: http://onecx-shell-bff:8080/
tags:
  - name: workspaceConfig
    description: Retrieve Workspace Configurations
  - name: parameter
    description: Retrieve Parameters
  - name: userProfile
    description: Retrieve the User Profile
  - name: permission
    description: Retrieve Permissions
paths:
  /workspaceConfig:
    post:
      x-onecx:
        permissions:
          workspaceConfig:
            - read
      tags:
        - workspaceConfig
      description: Load all data needed by startup of OneCX UI (components, routes, slots, theme, workspace)
      operationId: loadWorkspaceConfig
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LoadWorkspaceConfigRequest'
      responses:
        '200':
          description: Workspace configuration retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LoadWorkspaceConfigResponse'
        '400':
          description: Bad request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProblemDetailResponse'
        '404':
          description: Workspace configuration not found
  /workspaceConfig/themes/{name}/favicon:
    get:
      x-onecx:
        permissions:
          workspaceConfig:
            - read
      tags:
        - workspaceConfig
      description: Get favicon of a theme by its name
      operationId: getThemeFaviconByName
      parameters:
        - name: name
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: Favicon retrieved successfully
          content:
            image/x-icon:
              schema:
                minimum: 1
                maximum: 110000
                type: string
                format: binary
        404:
          description: Favicon not found

  /workspaceConfig/themes/{name}/logo:
    get:
      x-onecx:
        permissions:
          workspaceConfig:
            - read
      tags:
        - workspaceConfig
      description: Get the logo of a theme by its name
      operationId: getThemeLogoByName
      parameters:
        - name: name
          in: path
          required: true
          schema:
            type: string
        - name: small
          in: query
          required: false
          schema:
            type: boolean
            default: false
      responses:
        200:
          description: Logo retrieved successfully
          content:
            image/*:
              schema:
                minimum: 1
                maximum: 110000
                type: string
                format: binary
        404:
          description: Logo not found
  /workspaceConfig/themes/{name}/images/{refType}:
    get:
      x-onecx:
        permissions:
          workspaceConfig:
            - read
      tags:
        - workspaceConfig
      description: Get an image of a theme by its reference name (theme name) and reference type
      operationId: getThemeImageByNameAndRefType
      parameters:
        - name: name
          in: path
          required: true
          schema:
            type: string
        - name: refType
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: Image retrieved successfully
          content:
            image/*:
              schema:
                minimum: 1
                maximum: 110000
                type: string
                format: binary
        404:
          description: Image not found
  /workspaceConfig/themes/{name}/images/availableTypes:
    get:
      x-onecx:
        permissions:
          workspaceConfig:
            - read
      tags:
        - workspaceConfig
      description: Get available image types
      operationId: getAvailableImageTypes
      parameters:
        - name: name
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: Available image types retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AvailableImageTypes'
  /icons/{refId}:
    post:
      x-onecx:
        permissions:
          workspaceConfig:
            - read
      tags:
        - icon
      description: Retrieve icons by list of names and refId
      parameters:
        - name: refId
          in: path
          required: true
          schema:
            type: string
      operationId: findIconsByNamesAndRefId
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IconCriteria'
      responses:
        "200":
          description: Icons retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IconListResponse'
        "400":
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProblemDetailResponse'
  /parameters:
    post:
      x-onecx:
        permissions:
          parameter:
            - read
      tags:
        - parameter
      operationId: getParameters
      description: Get all available parameters of the requested products
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/GetParametersRequest'
      responses:
        '200':
          description: Parameters retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetParametersResponse'
        '400':
          description: Bad request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProblemDetailResponse'
  /userProfile:
    get:
      x-onecx:
        permissions:
          userProfile:
            - read
      tags:
        - userProfile
      operationId: getUserProfile
      description: Get the user profile of the requesting user
      responses:
        '200':
          description: User profile retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetUserProfileResponse'
        '400':
          description: Bad request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProblemDetailResponse'
        '404':
          description: User profile not found
  /permissions:
    post:
      x-onecx:
        permissions:
          permission:
            - read
      tags:
        - permission
      operationId: getPermissions
      description: Get all permissions for a specific application by its id and product name
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/GetPermissionsRequest'
      responses:
        '200':
          description: Permissions retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetPermissionsResponse'
        '400':
          description: Bad request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProblemDetailResponse'
        '404':
          description: Permissions not found
components:
  schemas:
    IconCriteria:
      type: object
      required:
        - names
      properties:
        names:
          minItems: 1
          type: array
          items:
            type: string
    IconListResponse:
      type: object
      properties:
        icons:
          type: array
          items:
            $ref: '#/components/schemas/Icon'
    Icon:
      type: object
      required:
        - name
        - body
        - type
      properties:
        name:
          type: string
        type:
          type: string
        body:
          type: string
        parent:
          type: string
    AvailableImageTypes:
      type: object
      properties:
        types:
          type: array
          items:
            type: string
    GetParametersRequest:
      type: object
      required:
        - products
      properties:
        products:
          type: object
          additionalProperties:
            uniqueItems: true
            type: array
            items:
              type: string
    GetParametersResponse:
      type: object
      required:
        - products
      properties:
        products:
          type: object
          additionalProperties:
            type: object
            additionalProperties:
              type: array
              items:
                $ref: '#/components/schemas/Parameter'
    Parameter:
      type: object
      required:
        - name
        - applicationId
        - productName
        - value
      properties:
        displayName:
          type: string
        description:
          type: string
        applicationId:
          type: string
        productName:
          type: string
        name:
          type: string
        value:
          $ref: '#/components/schemas/ParameterValue'
        importValue:
          $ref: '#/components/schemas/ParameterValue'
    ParameterValue:
      oneOf:
        - type: string
        - type: number
        - type: boolean
        - type: integer
        - type: object
    LoadWorkspaceConfigRequest:
      type: object
      required:
        - path
      properties:
        path:
          type: string
    LoadWorkspaceConfigResponse:
      type: object
      required:
        - 'routes'
        - 'theme'
        - 'workspace'
        - 'components'
        - 'slots'
      properties:
        routes:
          type: array
          items:
            $ref: '#/components/schemas/Route'
        theme:
          $ref: '#/components/schemas/Theme'
        workspace:
          $ref: '#/components/schemas/Workspace'
        components:
          type: array
          items:
            $ref: '#/components/schemas/RemoteComponent'
        slots:
          type: array
          items:
            $ref: '#/components/schemas/Slot'
    Slot:
      type: object
      required:
        - 'name'
        - 'components'
      properties:
        name:
          type: string
        components:
          type: array
          items:
            type: string
    GetPermissionsRequest:
      type: object
      required:
        - appId
        - productName
      properties:
        appId:
          type: string
        productName:
          type: string
    Workspace:
      type: object
      required:
        - name
        - baseUrl
      properties:
        displayName:
          type: string
        name:
          type: string
        baseUrl:
          type: string
        homePage:
          type: string
        logoUrl:
          type: string
        smallLogoUrl:
          type: string
    Theme:
      required:
      - name
      - properties
      type: object
      properties:
        displayName:
          type: string
        name:
          minLength: 2
          type: string
        cssFile:
          type: string
        description:
          type: string
        assetsUrl:
          type: string
        logoUrl:
          type: string
        smallLogoUrl:
          type: string
        faviconUrl:
          type: string
        previewImageUrl:
          type: string
        assetsUpdateDate:
          type: string
        properties:
          type: string
        overrides:
          type: array
          items:
            $ref: '#/components/schemas/ThemeOverride'
    ThemeOverride:
      type: object
      properties:
        type:
          $ref: '#/components/schemas/OverrideType'
        value:
          type: string
    OverrideType:
      type: string
      enum:
        - PRIMENG
        - CSS
    Route:
      type: object
      required:
        - 'url'
        - 'baseUrl'
        - 'remoteEntryUrl'
        - 'type'
        - 'exposedModule'
        - 'appId'
        - 'productName'
        - 'productVersion'
        - 'pathMatch'
        - 'displayName'
      properties:
        url:
          type: string
        baseUrl:
          type: string
        remoteEntryUrl:
          type: string
        appId:
          type: string
        productName:
          type: string
        productVersion:
          type: string
        technology:
          $ref: '#/components/schemas/Technologies'
        exposedModule:
          type: string
        pathMatch:
          $ref: '#/components/schemas/PathMatch'
        remoteName:
          type: string
        elementName:
          type: string
        displayName:
          type: string
        endpoints:
          type: array
          items:
            $ref: '#/components/schemas/UIEndpoint'
    UIEndpoint:
      type: object
      properties:
        path:
          type: string
        name:
          type: string
    Technologies:
      type: string
      enum: ['Angular', 'WebComponent', 'WebComponentScript', 'WebComponentModule' ]
    PathMatch:
      type: string
      enum: ['full', 'prefix']
    RemoteComponent:
      type: object
      required:
        - 'name'
        - 'url'
        - 'baseUrl'
        - 'remoteEntryUrl'
        - 'exposedModule'
        - 'appId'
        - 'productName'
      properties:
        name:
          type: string
        baseUrl:
          type: string
        remoteEntryUrl:
          type: string
        appId:
          type: string
        productName:
          type: string
        productVersion:
          type: string
        exposedModule:
          type: string
        remoteName:
          type: string
        elementName:
          type: string
        technology:
          $ref: '#/components/schemas/Technologies'
    GetUserProfileResponse:
      type: object
      required:
        - 'userProfile'
      properties:
        userProfile:
          $ref: '#/components/schemas/UserProfile'
    UserProfile:
      type: object
      required:
        - 'userId'
        - 'person'
      properties:
        userId:
          type: string
        organization:
          type: string
        issuer:
          type: string
        tenantId:
          type: string
        person:
          $ref: '#/components/schemas/UserPerson'
        accountSettings:
          $ref: '#/components/schemas/AccountSettings'
        settings:
          type: object
    UserPerson:
      type: object
      properties:
        firstName:
          type: string
        lastName:
          type: string
        displayName:
          type: string
        email:
          type: string
        address:
          $ref: '#/components/schemas/UserPersonAddress'
        phone:
          $ref: '#/components/schemas/UserPersonPhone'
    UserPersonAddress:
      type: object
      properties:
        street:
          type: string
        streetNo:
          type: string
        city:
          type: string
        postalCode:
          type: string
        country:
          type: string
    UserPersonPhone:
      type: object
      properties:
        type:
          $ref: '#/components/schemas/PhoneType'
        number:
          type: string
    PhoneType:
      type: string
      enum: ['MOBILE', 'LANDLINE']
    AccountSettings:
      type: object
      properties:
        layoutAndThemeSettings:
          $ref: '#/components/schemas/LayoutAndThemeSettings'
        localeAndTimeSettings:
          $ref: '#/components/schemas/LocaleAndTimeSettings'
    LayoutAndThemeSettings:
      type: object
      properties:
        colorScheme:
          $ref: '#/components/schemas/ColorScheme'
        menuMode:
          $ref: '#/components/schemas/MenuMode'
    ColorScheme:
      type: string
      enum: ['AUTO', 'LIGHT', 'DARK']
    MenuMode:
      type: string
      enum: ['HORIZONTAL', 'STATIC', 'OVERLAY', 'SLIM', 'SLIMPLUS']
    LocaleAndTimeSettings:
      type: object
      properties:
        locale:
          type: string
        timezone:
          type: string
    GetPermissionsResponse:
      type: object
      required:
        - permissions
      properties:
        permissions:
          type: array
          items:
            type: string
    ProblemDetailResponse:
      type: object
      properties:
        errorCode:
          type: string
        detail:
          type: string
        params:
          type: array
          items:
            $ref: '#/components/schemas/ProblemDetailParam'
        invalidParams:
          type: array
          items:
            $ref: '#/components/schemas/ProblemDetailInvalidParam'
    ProblemDetailParam:
      type: object
      properties:
        key:
          type: string
        value:
          type: string
    ProblemDetailInvalidParam:
      type: object
      properties:
        name:
          type: string
        message:
          type: string


```